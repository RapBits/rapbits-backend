package main

import (
	"encoding/json"
	"log"
	"net/http"
	"time"
)

type Rapbit struct {
	SongName   string `json:"songName"`
	Lyric      string `json:"lyric"`
	ArtistName string `json:"artistName"`
	AlbumCover string `json:"albumCover"`
	Mp3Snippet string `json:"mp3Snippet"`
	Mp4Snippet string `json:"mp4Snippet"`
	Tags       string `json:"tags"`
	Rowindex   string `json:"rowindex"`
}

type AutoGenerated struct {
	Version  string `json:"version"`
	Encoding string `json:"encoding"`
	Feed     struct {
		Xmlns           string `json:"xmlns"`
		XmlnsOpenSearch string `json:"xmlns$openSearch"`
		XmlnsGsx        string `json:"xmlns$gsx"`
		ID              struct {
			T string `json:"$t"`
		} `json:"id"`
		Updated struct {
			T time.Time `json:"$t"`
		} `json:"updated"`
		Category []struct {
			Scheme string `json:"scheme"`
			Term   string `json:"term"`
		} `json:"category"`
		Title struct {
			Type string `json:"type"`
			T    string `json:"$t"`
		} `json:"title"`
		Link []struct {
			Rel  string `json:"rel"`
			Type string `json:"type"`
			Href string `json:"href"`
		} `json:"link"`
		Author []struct {
			Name struct {
				T string `json:"$t"`
			} `json:"name"`
			Email struct {
				T string `json:"$t"`
			} `json:"email"`
		} `json:"author"`
		OpenSearchTotalResults struct {
			T string `json:"$t"`
		} `json:"openSearch$totalResults"`
		OpenSearchStartIndex struct {
			T string `json:"$t"`
		} `json:"openSearch$startIndex"`
		Entry []struct {
			ID struct {
				T string `json:"$t"`
			} `json:"id"`
			Updated struct {
				T time.Time `json:"$t"`
			} `json:"updated"`
			Category []struct {
				Scheme string `json:"scheme"`
				Term   string `json:"term"`
			} `json:"category"`
			Title struct {
				Type string `json:"type"`
				T    string `json:"$t"`
			} `json:"title"`
			Content struct {
				Type string `json:"type"`
				T    string `json:"$t"`
			} `json:"content"`
			Link []struct {
				Rel  string `json:"rel"`
				Type string `json:"type"`
				Href string `json:"href"`
			} `json:"link"`
			GsxSongname struct {
				T string `json:"$t"`
			} `json:"gsx$songname"`
			GsxLyric struct {
				T string `json:"$t"`
			} `json:"gsx$lyric"`
			GsxArtistname struct {
				T string `json:"$t"`
			} `json:"gsx$artistname"`
			GsxAlbumcover struct {
				T string `json:"$t"`
			} `json:"gsx$albumcover"`
			GsxMp3Snippet struct {
				T string `json:"$t"`
			} `json:"gsx$mp3snippet"`
			GsxTags struct {
				T string `json:"$t"`
			} `json:"gsx$tags"`
			GsxRowindex struct {
				T string `json:"$t"`
			} `json:"gsx$rowindex"`
			GsxMp4Snippet struct {
				T string `json:"$t"`
			} `json:"gsx$mp4snippet"`
		} `json:"entry"`
	} `json:"feed"`
}

func songsss(w http.ResponseWriter, r *http.Request) {
	if r.Method != "GET" {
		http.Error(w, "Expected GET request for /songs", http.StatusBadRequest)
	}

	resp, _ := http.Get("https://spreadsheets.google.com/feeds/list/1xlt3DSML1BX0l4LaLijzhz7JkZc5RxzPjL65cNIM3_Y/od6/public/values?alt=json")

	autoGenerated := new(AutoGenerated)

	if err := json.NewDecoder(resp.Body).Decode(autoGenerated); err != nil {
		log.Fatal(err)
	}

	var rapbits []Rapbit
	for _, rapbit := range autoGenerated.Feed.Entry {
		rapbits = append(rapbits, Rapbit{
			SongName:   rapbit.GsxSongname.T,
			Lyric:      rapbit.GsxLyric.T,
			ArtistName: rapbit.GsxArtistname.T,
			AlbumCover: rapbit.GsxAlbumcover.T,
			Mp3Snippet: rapbit.GsxMp3Snippet.T,
			Mp4Snippet: rapbit.GsxMp4Snippet.T,
			Tags:       rapbit.GsxTags.T,
			Rowindex:   rapbit.GsxRowindex.T})
	}

	m, err := json.Marshal(rapbits)

	if err != nil {
		log.Fatal("Cannot encode to JSON ", err)
	}

	w.Header().Set("Content-Type", "application/json")
	w.Write(m)
}
